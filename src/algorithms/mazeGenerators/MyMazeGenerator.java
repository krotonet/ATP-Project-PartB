package algorithms.mazeGenerators;

import java.util.*;

public class MyMazeGenerator extends AMazeGenerator{
    Random random = new Random();

    /**
     * starting maze full of walls, generating maze by breaking walls.
     * if any dimension(row or column) is lower or equal 2, we generate it as dimension 3.
     * goal position is chosen when stack of position is the largest and on maze's frontier
     * take the
     * @param rows
     * @param columns
     * @return Maze, generated by DFS algorithm
     */
    @Override
    public Maze generate(int rows, int columns) {
        if(rows <= 2) rows = 3;
        if(columns <= 2 ) columns=3;

        int endRow = 0, endColumn = 0;
        int maxStackSize = 0;

        //initialize maze, grid full of walls
        Maze maze = new Maze(rows, columns);
        maze.initializeMaze(1);

        //draw starting position on one of the sides
        Position startPosition = getRandomStartPosition(rows, columns);

        //draw starting position on any spot on the grid
        maze.setStartPosition(startPosition);
        maze.breakWall(startPosition.getRowIndex(),startPosition.getColumnIndex());
        //push starting cell to the stack
        Stack<Position> cells = new Stack<>();
        cells.push(maze.getStartPosition());

        //add walls of starting cell to a list
        List<Position> walls = new ArrayList<>();
        addCellsWalls(maze, walls, startPosition);

        while(!cells.isEmpty()){
            Position currentCell = cells.pop();

            //get current's cell neighbors
            List<Position> neighbors = getNeighbors(maze,currentCell);

            //current cell has neighbours which have not been visited
            if(!neighbors.isEmpty()){
                cells.push(currentCell);

                //randomly choose wall of current cell
                Position unvisited = getRandomWall(neighbors);
                //break wall between current and the next cell
                breakWall(maze, currentCell, unvisited);
                maze.breakWall(unvisited.getRowIndex(), unvisited.getColumnIndex());
                cells.push(unvisited);
            }
            //finding the end position
            if (cells.size() > maxStackSize && isFrontier(maze, currentCell) && !currentCell.equals(startPosition)) {
                maxStackSize = cells.size();
                endRow = currentCell.getRowIndex();
                endColumn = currentCell.getColumnIndex();
            }
        }
        maze.setGoalPosition(new Position(endRow, endColumn));

        return maze;
    }

    /**
     *
     * @param maze, current maze
     * @param currentCell , to compare with
     * @return boolean, true if position {row,col}
     */
    public boolean isFrontier(Maze maze, Position currentCell){
        boolean rowComparison = currentCell.getRowIndex() == maze.getRows() - 1 || currentCell.getRowIndex() == 0;
        boolean colComparison = currentCell.getColumnIndex() == maze.getColumns() - 1 || currentCell.getColumnIndex() == 0;
        return (rowComparison || colComparison) && maze.getValue(currentCell.getRowIndex(), currentCell.getColumnIndex()) != 1;
    }

    /**
     * break the needed wall between current cell and next cell
     * @param maze, current maze
     * @param currentCell, position, current cell in the maze
     * @param nextCell, position, cell to go forward
     */
    public void breakWall(Maze maze,Position currentCell, Position nextCell){
        //move on the same row
        if(nextCell.getRowIndex() == currentCell.getRowIndex()){
            //check if the move was to go right, else left
            if(nextCell.getColumnIndex() - currentCell.getColumnIndex() > 0)
                maze.breakWall(currentCell.getRowIndex(), currentCell.getColumnIndex() + 1);
            else
                maze.breakWall(currentCell.getRowIndex(), currentCell.getColumnIndex() - 1);
        }
        //move on the same column
        else{
            //check if the move was to go up, else down
            if(currentCell.getRowIndex() - nextCell.getRowIndex() > 0)
                maze.breakWall(currentCell.getRowIndex() - 1, currentCell.getColumnIndex());
            else
                maze.breakWall(currentCell.getRowIndex() + 1, currentCell.getColumnIndex());
        }
    }

    /**
     * generate random start position on the frontier
     * @param rows
     * @param columns
     * @return
     */
    public Position getRandomStartPosition(int rows, int columns){
        Position startPosition = null;
        int randomSide = random.nextInt(4) + 1;
        switch (randomSide) {
            //start from left side
            case 1 -> startPosition = new Position(random.nextInt(rows), 0);

            //start from upper side
            case 2 -> startPosition = new Position(0, random.nextInt(columns));

            //start from right side
            case 3 -> startPosition = new Position(random.nextInt(rows), columns - 1);

            //start from bottom
            case 4 -> startPosition = new Position(rows - 1, random.nextInt(columns));
        }
        return startPosition;
    }

    /**
     * creates list of neighbors for current cell
     * @param maze, current maze
     * @param currentCell, current cell
     * @return List of Positions
     */
    public List<Position> getNeighbors(Maze maze, Position currentCell){
        List<Position> cells = new LinkedList<>();
        if(currentCell.getColumnIndex() - 2 >= 0 && maze.getValue(currentCell.getRowIndex(),currentCell.getColumnIndex() - 2) == 1) {
            cells.add(new Position(currentCell.getRowIndex(),currentCell.getColumnIndex() - 2));
        }
        if(currentCell.getColumnIndex() + 2 < maze.getColumns() && maze.getValue(currentCell.getRowIndex(),currentCell.getColumnIndex() + 2) == 1) {
            cells.add(new Position(currentCell.getRowIndex(),currentCell.getColumnIndex() + 2));
        }
        if(currentCell.getRowIndex() - 2 >= 0 && maze.getValue(currentCell.getRowIndex() - 2, currentCell.getColumnIndex()) == 1) {
            cells.add(new Position(currentCell.getRowIndex() - 2,currentCell.getColumnIndex()));
        }
        if(currentCell.getRowIndex() + 2 < maze.getRows() && maze.getValue(currentCell.getRowIndex() + 2, currentCell.getColumnIndex()) == 1) {
            cells.add(new Position(currentCell.getRowIndex() + 2,currentCell.getColumnIndex()));
        }

        return cells;
    }

    /**
     * selects random wall for potential step
     * @param walls , List of Positions walls of current cell
     * @return Position
     */
    public Position getRandomWall(List<Position> walls){
        return walls.get(random.nextInt(walls.size()));
    }


    /**
     * adding walls of cell into walls list, 4 walls if cell isn't on the maze's boundaries
     * @param maze ,current maze
     * @param walls, List of positions adding walls of cell into this list
     * @param cell, Position, adding the walls of this cell
     */
    public void addCellsWalls(Maze maze, List<Position> walls, Position cell){
        if (cell.getColumnIndex() + 1 < maze.getColumns() && maze.getValue(cell.getRowIndex(), cell.getColumnIndex() + 1) == 1){
            walls.add(new Position(cell.getRowIndex(), cell.getColumnIndex() + 1));
        }
        if (cell.getColumnIndex() - 1 >= 0 && maze.getValue(cell.getRowIndex(), cell.getColumnIndex() - 1) == 1) {
            walls.add(new Position(cell.getRowIndex(), cell.getColumnIndex() - 1));
        }
        if (cell.getRowIndex() + 1 < maze.getRows() && maze.getValue(cell.getRowIndex() + 1, cell.getColumnIndex()) == 1) {
            walls.add(new Position(cell.getRowIndex() + 1, cell.getColumnIndex()));
        }
        if (cell.getRowIndex() - 1 >= 0 && maze.getValue(cell.getRowIndex() - 1, cell.getColumnIndex()) == 1) {
            walls.add(new Position(cell.getRowIndex() - 1, cell.getColumnIndex()));
        }
    }

}